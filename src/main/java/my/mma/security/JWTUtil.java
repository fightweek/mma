package my.mma.security;import io.jsonwebtoken.*;import my.mma.exception.CustomException;import my.mma.security.dto.JwtCrateDto;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.util.function.Function;import static my.mma.exception.CustomErrorCode.*;@Componentpublic class JWTUtil {    private final SecretKey secretKey;    public JWTUtil(@Value("${spring.jwt.secret}") String secret) {        secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), Jwts.SIG.HS256.key().build().getAlgorithm());    }    public String extractEmail(String token) {        return extractClaim(token, new Function<Claims, String>() {            @Override            public String apply(Claims claims) {                return claims.get("email", String.class);            }        });    }    public String extractCategory(String token) {        return extractClaim(token, claims -> claims.get("category", String.class));    }    public boolean extractIsSocial(String token) {        return extractClaim(token, claims -> claims.get("isSocial", Boolean.class));    }    public String extractDomain(String token) {        return extractClaim(token, claims -> claims.get("domain", String.class));    }    public String extractRole(String token) {        return extractClaim(token, claims -> claims.get("role", String.class));    }    public Claims extractAllClaims(String token) {        return Jwts.parser()                .verifyWith(secretKey)                .build()                .parseSignedClaims(token)                .getPayload();    }    // claim 안에 적어도 인증된 사용자의 고유 식별자와 role은 무조건 넣어야 한다    public String createJwt(JwtCrateDto crateDto) {        return crateDto.toJwtToken(secretKey);    }    public void validateToken(String token) {        try {            Jwts.parser()                    .verifyWith(secretKey)                    .build().parseSignedClaims(token);        } catch (ExpiredJwtException e) {            throw new CustomException(JWT_TOKEN_EXPIRED);        } catch (JwtException e) {            throw new CustomException(UNSUPPORTED_JWT);        } catch (Exception e) {            // 여기에서 예외 메시지를 설정해야 합니다.            throw new CustomException(SERVER_ERROR);        }    }    private Claims parseClaims(String token) {        return Jwts.parser()                .verifyWith(secretKey)                .build()                .parseSignedClaims(token)                .getPayload();    }    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {        final Claims claims = parseClaims(token);        return claimsResolver.apply(claims);    }}