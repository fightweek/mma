package my.mma.security.filter;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import jakarta.servlet.FilterChain;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import my.mma.exception.CustomErrorCode;import my.mma.exception.CustomException;import my.mma.security.JWTUtil;import my.mma.security.dto.JwtCrateDto;import my.mma.security.entity.Refresh;import my.mma.security.repository.RefreshRepository;import my.mma.user.entity.User;import my.mma.user.repository.UserRepository;import my.mma.user.service.UserService;import org.springframework.http.HttpStatus;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.transaction.annotation.Transactional;import java.io.BufferedReader;import java.io.IOException;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;@Slf4jpublic class LoginFilter extends UsernamePasswordAuthenticationFilter {    private final AuthenticationManager authenticationManager; // 구현체 : ProviderManager    private final JWTUtil jwtUtil;    private final RefreshRepository refreshRepository;    private final UserRepository userRepository;    private final Long accessExpireMs;    private final Long refreshExpireMs;    private final ObjectMapper objectMapper;    public LoginFilter(AuthenticationManager authenticationManager, JWTUtil jwtUtil, RefreshRepository refreshRepository,                       UserRepository userRepository, Long accessExpireMs, Long refreshExpireMs, ObjectMapper objectMapper) {        this.authenticationManager = authenticationManager;        this.jwtUtil = jwtUtil;        this.refreshRepository = refreshRepository;        this.userRepository = userRepository;        this.accessExpireMs = accessExpireMs;        this.refreshExpireMs = refreshExpireMs;        this.objectMapper  = objectMapper;        setFilterProcessesUrl("/auth/login");    }    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {        log.info("LoginFilter attemptAuthentication execute");        //클라이언트 요청에서 username, password 추출        String email;        String password;        String fcmToken;        try {            String requestBody = getRequestBody(request);            Map<String, String> jsonMap = objectMapper.readValue(requestBody, new TypeReference<>() {            });            email = jsonMap.get("email");            password = jsonMap.get("password");            fcmToken = jsonMap.get("fcmToken");        } catch (IOException e) {            log.info("error = ",e);            throw new CustomException(CustomErrorCode.SERVER_ERROR);        }        log.info("email={}", email);        log.info("pwd={}", password);        log.info("fcmToken={}",fcmToken);        //스프링 시큐리티에서 username과 password를 검증하기 위해서는 token에 담아야 함        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(email, password, null);        authToken.setDetails(fcmToken);        //token에 담은 검증을 위한 AuthenticationManager로 전달        return authenticationManager.authenticate(authToken);    }    //로그인 성공시 실행하는 메소드 (여기서 JWT를 발급하면 됨)    @Override    @Transactional    public void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) throws IOException {        String email = authentication.getName();        String fcmToken = (String) authentication.getDetails();        log.info("email={}", email);        log.info("fcmToken={}",fcmToken);        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();        Iterator<? extends GrantedAuthority> iterator = authorities.iterator();        GrantedAuthority auth = iterator.next();        String role = auth.getAuthority();        String access = jwtUtil.createJwt(JwtCrateDto.toDto(                "access", email, role, accessExpireMs, "LOCAL", false        ));        String refresh = jwtUtil.createJwt(JwtCrateDto.toDto(                "refresh", email, role, refreshExpireMs, "LOCAL", false        ));        User user = userRepository.findByEmail(email)                .orElseThrow(() -> new CustomException(CustomErrorCode.SERVER_ERROR));        user.updateFcmToken(fcmToken);        addRefreshEntity(email, refresh,refreshExpireMs);        response.setContentType("application/json");        response.setCharacterEncoding("UTF-8");        HashMap<String, String> tokens = new HashMap<>();        tokens.put("accessToken", access);        tokens.put("refreshToken", refresh);        String responseBody = objectMapper.writeValueAsString(tokens);        response.getWriter().write(responseBody);        response.setStatus(HttpStatus.OK.value());    }    private void addRefreshEntity(String username, String refresh, Long expiredMs) {        refreshRepository.save(Refresh.builder()                .email(username)                .token(refresh)                .expiration(expiredMs)                .build());    }    //로그인 실패시 실행하는 메소드    @Override    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) {        log.info("failed");        response.setStatus(401);    }    private String getRequestBody(HttpServletRequest request) throws IOException {        StringBuilder sb = new StringBuilder();        BufferedReader reader = request.getReader();        String line;        while ((line = reader.readLine()) != null) {            sb.append(line);        }        return sb.toString();    }}